// -----------------------------------------------------------------------------
// Author       :   Javier R. Juliani
// Date         :   01/08/2020
// Name         :   class_temperatures.cpp
// Description  :
// * This file is for defining the class of the temperatures of the cells
// -----------------------------------------------------------------------------
 /////////////////////////////////////////////////////////////////////This class is a fucking mess, it has to be changed
#include "class_temperatures.h"

int tam1, tam2, tam3;

OneWire OurWire1(37);
OneWire OurWire2(38);
OneWire OurWire3(25);
DallasTemperature sensors1(&OurWire1);    //Internal function of Library
DallasTemperature sensors2(&OurWire2);    //Internal function of Library
DallasTemperature sensors3(&OurWire3);    //Internal function of Library

DeviceAddress address1[] = {
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x64, 0x22, 0x30},    //  1
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6A, 0x84, 0x9E},    //  2
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x66, 0x7C, 0x65},    //  3
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x7D, 0xE6, 0xC5},    //  4
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x63, 0x30, 0x7F},    //  5
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6B, 0x13, 0xC8},    //  6
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x41, 0xAB, 0x51},    //  7
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x03, 0x36, 0xB7},    //  8
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x13, 0x77, 0x43},    //  9
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7C, 0x010, 0x9D},    //  10
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7A, 0xBB, 0xB8},    //  11
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x76, 0xEF, 0x4F},    //  12
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0x50, 0x4A},    //  13
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0xF4, 0x84},    //  14
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0x12, 0xB0},    //  15
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7D, 0x91, 0x8B},    //  16
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x63, 0x2E, 0xC8},    //  17
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7B, 0x3A, 0xAE},    //  18
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x80, 0x60, 0x2F},    //  19
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x80, 0x5E, 0x8E},    //  20
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x84, 0xE2, 0x24},    //  21
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x84, 0x19, 0x70},    //  22
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA4, 0x91, 0xFF},    //  23
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xAA, 0x15, 0xCE},    //  24
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x86, 0x95, 0xCE},    //  25
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x81, 0x29, 0x31},    //  26
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x81, 0xBF, 0xFD},    //  27
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x85, 0xCA, 0x01},    //  28
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x87, 0x94, 0x54},    //  29
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA7, 0xEA, 0x72},    //  30
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x60, 0x47, 0xB5},    //  31
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x66, 0x45, 0xA3},    //  32
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x7E, 0x1C, 0x7E},    //  33
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x61, 0xFC, 0x63},    //  34
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x61, 0x43, 0x010},    //  35
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x63, 0x25, 0x39},    //  36
};
DeviceAddress address2[] = {
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x64, 0x22, 0x30},    //  1
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6A, 0x84, 0x9E},    //  2
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x66, 0x7C, 0x65},    //  3
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x7D, 0xE6, 0xC5},    //  4
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x63, 0x30, 0x7F},    //  5
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6B, 0x13, 0xC8},    //  6
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x41, 0xAB, 0x51},    //  7
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x03, 0x36, 0xB7},    //  8
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x13, 0x77, 0x43},    //  9
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7C, 0x010, 0x9D},    //  10
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7A, 0xBB, 0xB8},    //  11
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x76, 0xEF, 0x4F},    //  12
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0x50, 0x4A},    //  13
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0xF4, 0x84},    //  14
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0x12, 0xB0},    //  15
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7D, 0x91, 0x8B},    //  16
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x63, 0x2E, 0xC8},    //  17
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7B, 0x3A, 0xAE},    //  18
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x80, 0x60, 0x2F},    //  19
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x80, 0x5E, 0x8E},    //  20
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x84, 0xE2, 0x24},    //  21
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x84, 0x19, 0x70},    //  22
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA4, 0x91, 0xFF},    //  23
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xAA, 0x15, 0xCE},    //  24
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x86, 0x95, 0xCE},    //  25
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x81, 0x29, 0x31},    //  26
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x81, 0xBF, 0xFD},    //  27
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x85, 0xCA, 0x01},    //  28
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x87, 0x94, 0x54},    //  29
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA7, 0xEA, 0x72},    //  30
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x60, 0x47, 0xB5},    //  31
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x66, 0x45, 0xA3},    //  32
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x7E, 0x1C, 0x7E},    //  33
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x61, 0xFC, 0x63},    //  34
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x61, 0x43, 0x010},    //  35
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x63, 0x25, 0x39},    //  36
};
DeviceAddress address3[] = {
        {0x28, 0x46, 0x1A, 0xC5, 0x0B, 0x00, 0x00, 0x61},    //  1
        {0x28, 0x45, 0x50, 0xC5, 0x0B, 0x00, 0x00, 0x6C},    //  2
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x60, 0xEB, 0x5D},    //  3
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x14, 0x01, 0x47},    //  4
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6A, 0xED, 0x67},    //  5
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x61, 0xEA, 0xC7},    //  6
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x63, 0xDF, 0xD7},    //  7
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x6B, 0x4B, 0xD1},    //  8
        {0x28, 0xFF, 0x64, 0x01, 0xBC, 0x1B, 0xBD, 0xCE},    //  9
        {0x28, 0xFF, 0x64, 0x01, 0xBE, 0x0B, 0x64, 0xA6},    //  10
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7E, 0x62, 0x48},    //  11
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x75, 0x3C, 0xAF},    //  12
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x6D, 0x44, 0x0F},    //  13
        {0x28, 0xFF, 0x64, 0x01, 0xB9, 0x7F, 0xF3, 0xC3},    //  14
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA4, 0x69, 0x49},    //  15
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0x86, 0x23, 0x21},    //  16
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xA7, 0x25, 0xF9},    //  17
        {0x28, 0xFF, 0x64, 0x01, 0xBD, 0xAF, 0x3E, 0x32},    //  18
        {0x28, 0xFF, 0x64, 0x01, 0xBF, 0x8A, 0xAF, 0x0C},    //  19
};




Temperatures_MOD::Temperatures_MOD(INT32U _ID,int _T_MAX, int _LAG)
{
  ID = _ID;
  time_lim_sended += _LAG;
  Maximun_Temperature = _T_MAX;
  tam1 = sizeof(address1)/8;
  tam2 = sizeof(address2)/8;
  tam3 = sizeof(address3)/8;
  //sensors1.begin();              //Internal function of library
  //sensors2.begin();
  sensors3.begin();


  time_lim_plotted += _LAG;
  time_lim_measure += _LAG;
  for(int i = 0; i < 95; i++)
  {
    Tempe[i] = 0;
  }
}

void Temperatures_MOD::Measure_Temp()
{
  //sensors1.requestTemperatures();
  //sensors2.requestTemperatures();
  sensors3.requestTemperatures();
  /*if(j == 0)
  {
    for(int i=tam*j/4; i<tam/4; i++)
    {
      Tempt[i]=sensors1.getTempC(address1[i]);  //Intenal function of library
      Tempe[i]=int(Tempt[i]);
    }
    j++;
  }
  else if(j == 1)
    for(int i=tam*j/4; i<tam/4; i++)
    {
      Tempt[i]=sensors1.getTempC(address1[i]);  //Intenal function of library
      Tempe[i]=int(Tempt[i]);
    }
    j++;
  }
  else if(j == 2)
  {
    for(int i=tam*j/4; i<tam/4; i++)
    {
      Tempt[i]=sensors1.getTempC(address1[i]);  //Intenal function of library
      {
      Tempe[i]=int(Tempt[i]);
    }
    j++;
  }
  else if(j == 3)
  {
    for(int i=tam*j/4; i<tam/4; i++)
    {
      Tempt[i]=sensors1.getTempC(address1[i]);  //Intenal function of library
      Tempe[i]=int(Tempt[i]);
    }
    j = 0;
  }*/
  for(int i=0; i<tam3; i++)
  {
    Tempt[i]=sensors3.getTempC(address3[i]);  //Intenal function of library
    Tempe[i]=int(Tempt[i]);
  }
  for(int i = 0; i<95; i++)
  {
    if((Tempe[i] > 25) || (Tempe[i] < 27)) Tempe[i] = 25 + (i%2);
  }
  MAX_T = Tempe[0];
  for (int j=0; j<95; j++)
  {
    //if(Serial) Serial.println(Tempe[j]);
      if(Tempe[j]>MAX_T)
      {
        MAX_T = Tempe[j];
      }
  }
}





// ********************************************************************************************************
// **Function name:           info
// **Descriptions:            Function for printing the class data
// **********************************************************************************************************
void Temperatures_MOD::info(char *buffer)
{
   error=0;
  if(Serial){     // Send the message just if there is a serial port connected
    Serial.println("\n***********************");
    Serial.println("         Temperatures");
    Serial.println("***********************");
    sprintf(buffer, " - ERROR:     %i", error);           Serial.println(buffer);
    sprintf(buffer, " - CAN ID:    0x%lx", ID);        Serial.println(buffer);
    sprintf(buffer, " - MAX T =    %i ºC", Maximun_Temperature);  Serial.println(buffer);
    sprintf(buffer, " - MIN T =    %i ºC", Minimun_Temperature);  Serial.println(buffer);
    sprintf(buffer, " - LIM T =    %i ºC", T_MAX);
    Serial.println("-----------------------");
    sprintf(buffer, "Temperatures (ºC): [%i", Tempe[0]); Serial.print(buffer);
       for (int i=0; i<19; i++){
         sprintf(buffer, ", %i", Tempe[i]);
         Serial.print(buffer);
       }
       Serial.println("]");
  }
}


// ** Function name:           query
/*
// ********************************************************************************************************
// **Function name:           return_error
// **Descriptions:            Function for returning the state of the BMS
// **********************************************************************************************************
int BMS_MOD::return_error()
{
  return error;
}
*/
// ********************************************************************************************************
// ** Descriptions:            Function to check if i need to send a mesage new mesage and the received mesajes interval are within the limits
// **********************************************************************************************************
int Temperatures_MOD::query(INT32U time, char *buffer)
{
    error = Temperatures_OK;
// Function for performing a correct behaivour
    if(time > time_lim_measure)
    {
      time_lim_measure += TIME_LIM_MEASURE;
      Measure_Temp();
      if(MAX_T > Maximun_Temperature)
      {
        error = Temperatures_ERROR_MAXIMUN_T;
      }
    }
    if(time > time_lim_sended)
    {
      time_lim_sended += TIME_LIM_SEND;

      message[0] = 0;
      message[1] = MAX_T & 0xFF;
      module_send_message_CAN1(ID, 0, 2, message);
    }
    if (TIME_LIM_PLOT>0 && time>time_lim_plotted){
      time_lim_plotted += TIME_LIM_PLOT;
      info(buffer);
    }
  return error;
}

// ********************************************************************************************************
//  END FILE
// **********************************************************************************************************
